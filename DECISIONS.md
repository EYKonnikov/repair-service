# Ключевые решения (DECISIONS)

## 1. PostgreSQL вместо SQLite

Выбран PostgreSQL, так как он обеспечивает надёжную обработку конкурентных запросов (race condition) через атомарные UPDATE с условием WHERE. SQLite имеет ограничения при параллельной записи.

## 2. Drizzle ORM для работы с БД

Drizzle ORM выбран как легковесная, типобезопасная ORM с хорошей интеграцией с TypeScript и Zod. Позволяет описывать схему в одном месте и генерировать типы для фронтенда и бэкенда.

## 3. Атомарный UPDATE для защиты от гонки

Действие «Взять в работу» реализовано через один SQL-запрос `UPDATE ... SET status='in_progress' WHERE id=? AND status='assigned' AND assigned_to=?`. Если два запроса приходят одновременно, только один из них изменит строку, второй получит пустой результат и вернёт 409 Conflict. Никаких блокировок или транзакций с ручным управлением не требуется.

## 4. Сессионная авторизация (express-session)

Выбрана простая сессионная авторизация вместо JWT. Для учебного проекта это достаточно, хранилище сессий — PostgreSQL через connect-pg-simple. Пароли хранятся в открытом виде (требование задания — упрощённая авторизация).

## 5. Единая схема данных (shared/schema.ts)

Типы данных, Zod-схемы валидации и Drizzle-схема БД определены в одном файле `shared/schema.ts`. Это обеспечивает консистентность типов между фронтендом и бэкендом без дублирования.

## 6. React + TanStack Query для фронтенда

TanStack Query используется для управления серверным состоянием: автоматическое кэширование, инвалидация при мутациях, обработка ошибок. Это упрощает код по сравнению с ручным управлением fetch + useState.

## 7. Seed-данные при запуске

При первом запуске приложение автоматически создаёт тестовых пользователей (1 диспетчер, 2 мастера) и 5 заявок в разных статусах. Это позволяет сразу проверить все функции без ручного создания данных. Повторная вставка не происходит — проверяется наличие пользователей.
